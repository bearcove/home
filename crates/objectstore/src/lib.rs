#![allow(unused_imports)]
// This file is automatically @generated by dylo
// To regenerate, run `dylo gen` in the root of the workspace directory
// For more information, see https://github.com/bearcove/dylo
include!(".dylo/spec.rs");
include!(".dylo/support.rs");
pub use bytes::Bytes;
use rubicon as _;
use futures_core::future::BoxFuture;
use futures_util::stream::BoxStream;
use std::{borrow::Cow, ops::Range, sync::Arc};
use config::{AwsSecrets, Environment, ObjectStorageConfig};
plait::plait! {
    with crates { merde #[cfg(feature = "rusqlite")] rusqlite } #[doc =
    " The key of an object in the object store"] pub struct ObjectStoreKey => &
    ObjectStoreKeyRef;
}
/// Options for a put request
#[derive(Default, Clone)]
pub struct PutOptions {
    /// Content type of the object
    pub content_type: Option<Cow<'static, str>>,
}
pub struct PutResult {
    pub e_tag: Option<String>,
    pub version: Option<String>,
}
/// Options for a put_multipart request
pub type PutMultipartOpts = PutOptions;
#[derive(Clone)]
pub enum GetRange {
    /// Request a specific range of bytes
    ///
    /// If the given range is zero-length or starts after the end of the object,
    /// an error will be returned. Additionally, if the range ends after the end
    /// of the object, the entire remainder of the object will be returned.
    /// Otherwise, the exact requested range will be returned.
    Bounded(Range<usize>),
    /// Request all bytes starting from a given byte offset
    Offset(usize),
    /// Request up to the last n bytes
    Suffix(usize),
}
#[derive(Clone, Default)]
pub struct GetOptions {
    /// Byte range to request
    pub range: Option<GetRange>,
    /// Whether this is a HEAD request
    pub head: bool,
}
#[derive(Debug)]
pub enum ErrorKind {
    NotFound,
    Other,
}
impl std::fmt::Display for ErrorKind {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.as_str())
    }
}
impl ErrorKind {
    pub fn as_str(&self) -> &'static str {
        match self {
            ErrorKind::NotFound => "not found",
            ErrorKind::Other => "other",
        }
    }
}
#[derive(Debug)]
pub struct Error {
    pub kind: ErrorKind,
    pub source: Box<dyn std::error::Error + Send + Sync>,
}
impl std::fmt::Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.kind)
    }
}
impl std::error::Error for Error {}
impl Error {
    pub fn is_not_found(&self) -> bool {
        matches!(self.kind, ErrorKind::NotFound)
    }
}
pub type Result<T, E = Error> = std::result::Result<T, E>;
pub struct LayeredBuilder<'a, M: ?Sized> {
    m: &'a M,
    stores: Vec<(String, Arc<dyn ObjectStore>)>,
}
impl<'a, M: Mod + ?Sized> LayeredBuilder<'a, M> {
    pub fn new(m: &'a M) -> Self {
        Self {
            m,
            stores: Default::default(),
        }
    }
    /// Add a store to the layered store
    pub fn layer(mut self, name: String, store: Arc<dyn ObjectStore>) -> Self {
        self.stores.push((name, store));
        self
    }
    /// Build the layered store
    pub fn finish(self) -> Arc<dyn ObjectStore> {
        self.m.layered(self.stores)
    }
}
impl dyn ObjectStore {
    pub fn get(
        &self,
        key: &ObjectStoreKeyRef,
    ) -> BoxFuture<'_, Result<Box<dyn GetResult>>> {
        self.get_opts(key, GetOptions::default())
    }
    pub fn put(
        &self,
        key: &ObjectStoreKeyRef,
        payload: Bytes,
    ) -> BoxFuture<'_, Result<PutResult>> {
        self.put_opts(key, payload, PutOptions::default())
    }
}
struct SimpleGetResult {
    size: usize,
    content_type: Option<String>,
    bytes: Bytes,
}
impl GetResult for SimpleGetResult {
    fn size(&self) -> usize {
        self.size
    }
    fn range(&self) -> std::ops::Range<usize> {
        0..self.size
    }
    fn content_type(&self) -> Option<&str> {
        self.content_type.as_deref()
    }
    fn bytes(self: Box<Self>) -> BoxFuture<'static, Result<Bytes>> {
        Box::pin(async move { Ok(self.bytes) })
    }
    fn into_stream(self: Box<Self>) -> BoxStream<'static, Result<Bytes>> {
        Box::pin(futures_util::stream::once(async move { Ok(self.bytes) }))
    }
}
pub fn input_key(hash: &str, ext: &str) -> ObjectStoreKey {
    let prefix = "inputs";
    let first_two = &hash[..2];
    if ext.is_empty() {
        ObjectStoreKey::new(format!("{prefix}/{first_two}/{hash}"))
    } else {
        ObjectStoreKey::new(format!("{prefix}/{first_two}/{hash}.{ext}"))
    }
}
pub fn derivation_key(env: Environment, hash: &str, ext: &str) -> ObjectStoreKey {
    let prefix = if env.is_prod() {
        "production/derivations"
    } else {
        "development/derivations"
    };
    let first_two = &hash[..2];
    if ext.is_empty() {
        ObjectStoreKey::new(format!("{prefix}/{first_two}/{hash}"))
    } else {
        ObjectStoreKey::new(format!("{prefix}/{first_two}/{hash}.{ext}"))
    }
}
