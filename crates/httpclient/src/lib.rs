#![allow(unused_imports)]
// This file is automatically @generated by dylo
// To regenerate, run `dylo gen` in the root of the workspace directory
// For more information, see https://github.com/bearcove/dylo
include!(".dylo/spec.rs");
include!(".dylo/support.rs");
pub use bytes::Bytes;
use futures_core::{future::BoxFuture, stream::BoxStream};
use merde::{DynSerialize, MerdeError};
use std::collections::HashMap;
pub use form_urlencoded;
pub use http::{
    HeaderMap, HeaderName, HeaderValue, Method, StatusCode, Uri, header, request,
    response,
};
#[derive(Debug)]
pub enum Error {
    /// Any other error
    Any(String),
    /// JSON parsing error
    Json(String),
    /// HTTP error
    Non200Status { status: StatusCode, response: String },
}
impl std::fmt::Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Error::Any(s) => write!(f, "{}", s),
            Error::Json(s) => write!(f, "{}", s),
            Error::Non200Status { status, response } => {
                write!(f, "HTTP status {}: {}", status, response)
            }
        }
    }
}
impl std::error::Error for Error {}
#[derive(Clone)]
pub struct ClientOpts {
    pub resolve_to_addrs: HashMap<String, Vec<std::net::SocketAddr>>,
    pub follow_redirects: bool,
}
impl dyn Response {
    #[cfg(feature = "json")]
    pub fn json<T: merde::DeserializeOwned>(
        self: Box<Self>,
    ) -> BoxFuture<'static, Result<T, Error>> {
        Box::pin(async move {
            let bytes = self.bytes().await?;
            merde::json::from_bytes_owned(&bytes).map_err(|e| Error::Json(e.to_string()))
        })
    }
}
