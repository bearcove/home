use std::{collections::VecDeque, sync::Arc};

use config::{TenantInfo, WebConfig};
use conflux::{InputPath, PathMappings, Revision};
use cub_types::{CubRevisionState, IndexedRevision, PathMetadata};
use futures_core::future::BoxFuture;

#[derive(Default)]
struct ModImpl;

/// All the information needed to build a new revision
pub struct RevisionSpec {
    pub kind: RevisionKind,
    pub mappings: PathMappings,
}

#[autotrait]
impl Mod for ModImpl {
    fn load_initial_revision(
        &self,
        ti: Arc<TenantInfo>,
        web: WebConfig,
    ) -> BoxFuture<'_, CubRevisionState> {
        Box::pin(impls::load_initial_revision(ti, web))
    }

    fn make_revision(
        &self,
        ti: Arc<TenantInfo>,
        spec: RevisionSpec,
        web: WebConfig,
    ) -> BoxFuture<'_, eyre::Result<IndexedRevision>> {
        Box::pin(impls::make::make_revision(ti, spec, web))
    }

    fn input_hash_from_contents(&self, contents: &[u8]) -> conflux::InputHash {
        impls::make::input_hash_from_contents(contents)
    }

    fn serialize_pak(&self, pak: &conflux::Pak<'_>) -> Vec<u8> {
        impls::serialize_pak(pak)
    }

    fn load_pak<'fut>(
        &'fut self,
        pak: conflux::Pak<'static>,
        ti: Arc<TenantInfo>,
        prev_rev: Option<&'fut conflux::Revision>,
        mappings: PathMappings,
        web: WebConfig,
    ) -> BoxFuture<'fut, eyre::Result<IndexedRevision>> {
        Box::pin(impls::load::load_pak(pak, ti, prev_rev, mappings, web))
    }

    fn start_watching(
        &self,
        tenant: Arc<dyn cub_types::CubTenant>,
        web: WebConfig,
    ) -> BoxFuture<'_, eyre::Result<()>> {
        Box::pin(impls::watch::start_watching(tenant, web))
    }

    fn save_pak_to_disk_as_active<'fut>(
        &'fut self,
        pak: &'fut conflux::Pak<'_>,
        ti: &'fut TenantInfo,
    ) -> BoxFuture<'fut, eyre::Result<()>> {
        Box::pin(impls::save_pak_to_disk_as_active(pak, ti))
    }
}

mod impls;

#[derive(Clone, Debug, PartialEq, Eq, Hash)]
pub enum InputEvent {
    Created {
        path: InputPath,
        metadata: PathMetadata,
    },
    Modified {
        path: InputPath,
        metadata: PathMetadata,
    },
    Removed(InputPath),
    NewMetadata {
        path: InputPath,
        metadata: PathMetadata,
    },
}

pub enum RevisionKind {
    FromScratch,
    Wake {
        prev: IndexedRevision,
        // we don't have events, those are generated by walking the disk
        // and comparing with the previous revision
    },
    Incremental {
        prev: Arc<Revision>,
        events: VecDeque<InputEvent>,
    },
}

impl std::fmt::Display for RevisionKind {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            RevisionKind::FromScratch => write!(f, "FromScratch"),
            RevisionKind::Wake { prev } => write!(f, "Wake(prev={}, 0 events)", prev.rev.pak.id),
            RevisionKind::Incremental { prev, events } => {
                write!(
                    f,
                    "Incremental(prev={}, {} events)",
                    prev.pak.id,
                    events.len()
                )
            }
        }
    }
}
