#![allow(unused_imports)]
// This file is automatically @generated by dylo
// To regenerate, run `dylo gen` in the root of the workspace directory
// For more information, see https://github.com/bearcove/dylo
use std::{collections::VecDeque, sync::Arc};
use config::{TenantInfo, WebConfig};
use conflux::{InputPath, PathMappings, Revision};
use cub_types::{CubRevisionState, IndexedRevision, PathMetadata};
use futures_core::future::BoxFuture;
/// All the information needed to build a new revision
pub struct RevisionSpec {
    pub kind: RevisionKind,
    pub mappings: PathMappings,
}
#[derive(Clone, Debug, PartialEq, Eq, Hash)]
pub enum InputEvent {
    Created { path: InputPath, metadata: PathMetadata },
    Modified { path: InputPath, metadata: PathMetadata },
    Removed(InputPath),
    NewMetadata { path: InputPath, metadata: PathMetadata },
}
pub enum RevisionKind {
    FromScratch,
    Wake { prev: IndexedRevision },
    Incremental { prev: Arc<Revision>, events: VecDeque<InputEvent> },
}
impl std::fmt::Display for RevisionKind {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            RevisionKind::FromScratch => write!(f, "FromScratch"),
            RevisionKind::Wake { prev } => {
                write!(f, "Wake(prev={}, 0 events)", prev.rev.pak.id)
            }
            RevisionKind::Incremental { prev, events } => {
                write!(f, "Incremental(prev={}, {} events)", prev.pak.id, events.len())
            }
        }
    }
}
include!(".dylo/spec.rs");
include!(".dylo/support.rs");
